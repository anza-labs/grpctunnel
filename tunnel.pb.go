// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/jhump/grpctunnel/tunnel.proto

package grpctunnel

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import empty "github.com/golang/protobuf/ptypes/empty"
import status "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ClientToServer is the message a client sends to a server.
//
// For a single stream ID, the first such message must include the new_stream
// field. After that, there can be any number of requests sent, via the
// request_message field and additional messages thereafter that use the
// more_request_data field (for requests that are larger than 16kb). And
// finally, the RPC ends with either the half_close or cancel fields. If the
// half_close field is used, the RPC stream remains active so the server may
// continue to send response data. But, if the cancel field is used, the RPC
// stream is aborted and thus closed on both client and server ends. If a stream
// has been half-closed, the only allowed message from the client for that
// stream ID is one with the cancel field, to abort the remainder of the
// operation.
type ClientToServer struct {
	// The ID of the stream. Unlike in the HTTP/2 protocol, the stream IDs used
	// do not have to be used sequentially, in monotonically increasing order,
	// and can potentially be re-used (as long as no stream with the same ID is still
	// active). However, it is 64-bit so that re-use due to overflow is extremely
	// unlikely.
	StreamId int64 `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// Types that are valid to be assigned to Frame:
	//	*ClientToServer_NewStream
	//	*ClientToServer_RequestMessage
	//	*ClientToServer_MoreRequestData
	//	*ClientToServer_HalfClose
	//	*ClientToServer_Cancel
	Frame                isClientToServer_Frame `protobuf_oneof:"frame"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ClientToServer) Reset()         { *m = ClientToServer{} }
func (m *ClientToServer) String() string { return proto.CompactTextString(m) }
func (*ClientToServer) ProtoMessage()    {}
func (*ClientToServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{0}
}
func (m *ClientToServer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientToServer.Unmarshal(m, b)
}
func (m *ClientToServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientToServer.Marshal(b, m, deterministic)
}
func (dst *ClientToServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientToServer.Merge(dst, src)
}
func (m *ClientToServer) XXX_Size() int {
	return xxx_messageInfo_ClientToServer.Size(m)
}
func (m *ClientToServer) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientToServer.DiscardUnknown(m)
}

var xxx_messageInfo_ClientToServer proto.InternalMessageInfo

type isClientToServer_Frame interface {
	isClientToServer_Frame()
}

type ClientToServer_NewStream struct {
	NewStream *NewStream `protobuf:"bytes,2,opt,name=new_stream,json=newStream,proto3,oneof"`
}
type ClientToServer_RequestMessage struct {
	RequestMessage *MessageData `protobuf:"bytes,3,opt,name=request_message,json=requestMessage,proto3,oneof"`
}
type ClientToServer_MoreRequestData struct {
	MoreRequestData []byte `protobuf:"bytes,4,opt,name=more_request_data,json=moreRequestData,proto3,oneof"`
}
type ClientToServer_HalfClose struct {
	HalfClose *empty.Empty `protobuf:"bytes,5,opt,name=half_close,json=halfClose,proto3,oneof"`
}
type ClientToServer_Cancel struct {
	Cancel *empty.Empty `protobuf:"bytes,6,opt,name=cancel,proto3,oneof"`
}

func (*ClientToServer_NewStream) isClientToServer_Frame()       {}
func (*ClientToServer_RequestMessage) isClientToServer_Frame()  {}
func (*ClientToServer_MoreRequestData) isClientToServer_Frame() {}
func (*ClientToServer_HalfClose) isClientToServer_Frame()       {}
func (*ClientToServer_Cancel) isClientToServer_Frame()          {}

func (m *ClientToServer) GetFrame() isClientToServer_Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *ClientToServer) GetStreamId() int64 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

func (m *ClientToServer) GetNewStream() *NewStream {
	if x, ok := m.GetFrame().(*ClientToServer_NewStream); ok {
		return x.NewStream
	}
	return nil
}

func (m *ClientToServer) GetRequestMessage() *MessageData {
	if x, ok := m.GetFrame().(*ClientToServer_RequestMessage); ok {
		return x.RequestMessage
	}
	return nil
}

func (m *ClientToServer) GetMoreRequestData() []byte {
	if x, ok := m.GetFrame().(*ClientToServer_MoreRequestData); ok {
		return x.MoreRequestData
	}
	return nil
}

func (m *ClientToServer) GetHalfClose() *empty.Empty {
	if x, ok := m.GetFrame().(*ClientToServer_HalfClose); ok {
		return x.HalfClose
	}
	return nil
}

func (m *ClientToServer) GetCancel() *empty.Empty {
	if x, ok := m.GetFrame().(*ClientToServer_Cancel); ok {
		return x.Cancel
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientToServer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientToServer_OneofMarshaler, _ClientToServer_OneofUnmarshaler, _ClientToServer_OneofSizer, []interface{}{
		(*ClientToServer_NewStream)(nil),
		(*ClientToServer_RequestMessage)(nil),
		(*ClientToServer_MoreRequestData)(nil),
		(*ClientToServer_HalfClose)(nil),
		(*ClientToServer_Cancel)(nil),
	}
}

func _ClientToServer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientToServer)
	// frame
	switch x := m.Frame.(type) {
	case *ClientToServer_NewStream:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewStream); err != nil {
			return err
		}
	case *ClientToServer_RequestMessage:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestMessage); err != nil {
			return err
		}
	case *ClientToServer_MoreRequestData:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.MoreRequestData)
	case *ClientToServer_HalfClose:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HalfClose); err != nil {
			return err
		}
	case *ClientToServer_Cancel:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cancel); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientToServer.Frame has unexpected type %T", x)
	}
	return nil
}

func _ClientToServer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientToServer)
	switch tag {
	case 2: // frame.new_stream
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NewStream)
		err := b.DecodeMessage(msg)
		m.Frame = &ClientToServer_NewStream{msg}
		return true, err
	case 3: // frame.request_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MessageData)
		err := b.DecodeMessage(msg)
		m.Frame = &ClientToServer_RequestMessage{msg}
		return true, err
	case 4: // frame.more_request_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Frame = &ClientToServer_MoreRequestData{x}
		return true, err
	case 5: // frame.half_close
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(empty.Empty)
		err := b.DecodeMessage(msg)
		m.Frame = &ClientToServer_HalfClose{msg}
		return true, err
	case 6: // frame.cancel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(empty.Empty)
		err := b.DecodeMessage(msg)
		m.Frame = &ClientToServer_Cancel{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientToServer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientToServer)
	// frame
	switch x := m.Frame.(type) {
	case *ClientToServer_NewStream:
		s := proto.Size(x.NewStream)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientToServer_RequestMessage:
		s := proto.Size(x.RequestMessage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientToServer_MoreRequestData:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.MoreRequestData)))
		n += len(x.MoreRequestData)
	case *ClientToServer_HalfClose:
		s := proto.Size(x.HalfClose)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientToServer_Cancel:
		s := proto.Size(x.Cancel)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ServerToClient is the message a server sends to a client.
//
// For a single stream ID, the first such message should include the
// response_headers field unless no headers are to be sent. After the headers,
// the server can send any number of responses, via the response_message field
// and additional messages thereafter that use the more_response_data field (for
// responses that are larger than 16kb). A message with the close_stream field
// concludes the stream, whether it terminates successfully or with an error.
type ServerToClient struct {
	// The ID of the stream. Unlike in the HTTP/2 protocol, the stream IDs used
	// do not have to be used sequentially, in monotonically increasing order,
	// and can safely be re-used (as long as no stream with the same ID is still
	// active).
	StreamId int64 `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// Types that are valid to be assigned to Frame:
	//	*ServerToClient_ResponseHeaders
	//	*ServerToClient_ResponseMessage
	//	*ServerToClient_MoreResponseData
	//	*ServerToClient_CloseStream
	Frame                isServerToClient_Frame `protobuf_oneof:"frame"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ServerToClient) Reset()         { *m = ServerToClient{} }
func (m *ServerToClient) String() string { return proto.CompactTextString(m) }
func (*ServerToClient) ProtoMessage()    {}
func (*ServerToClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{1}
}
func (m *ServerToClient) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerToClient.Unmarshal(m, b)
}
func (m *ServerToClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerToClient.Marshal(b, m, deterministic)
}
func (dst *ServerToClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerToClient.Merge(dst, src)
}
func (m *ServerToClient) XXX_Size() int {
	return xxx_messageInfo_ServerToClient.Size(m)
}
func (m *ServerToClient) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerToClient.DiscardUnknown(m)
}

var xxx_messageInfo_ServerToClient proto.InternalMessageInfo

type isServerToClient_Frame interface {
	isServerToClient_Frame()
}

type ServerToClient_ResponseHeaders struct {
	ResponseHeaders *Metadata `protobuf:"bytes,2,opt,name=response_headers,json=responseHeaders,proto3,oneof"`
}
type ServerToClient_ResponseMessage struct {
	ResponseMessage *MessageData `protobuf:"bytes,3,opt,name=response_message,json=responseMessage,proto3,oneof"`
}
type ServerToClient_MoreResponseData struct {
	MoreResponseData []byte `protobuf:"bytes,4,opt,name=more_response_data,json=moreResponseData,proto3,oneof"`
}
type ServerToClient_CloseStream struct {
	CloseStream *CloseStream `protobuf:"bytes,5,opt,name=close_stream,json=closeStream,proto3,oneof"`
}

func (*ServerToClient_ResponseHeaders) isServerToClient_Frame()  {}
func (*ServerToClient_ResponseMessage) isServerToClient_Frame()  {}
func (*ServerToClient_MoreResponseData) isServerToClient_Frame() {}
func (*ServerToClient_CloseStream) isServerToClient_Frame()      {}

func (m *ServerToClient) GetFrame() isServerToClient_Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *ServerToClient) GetStreamId() int64 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

func (m *ServerToClient) GetResponseHeaders() *Metadata {
	if x, ok := m.GetFrame().(*ServerToClient_ResponseHeaders); ok {
		return x.ResponseHeaders
	}
	return nil
}

func (m *ServerToClient) GetResponseMessage() *MessageData {
	if x, ok := m.GetFrame().(*ServerToClient_ResponseMessage); ok {
		return x.ResponseMessage
	}
	return nil
}

func (m *ServerToClient) GetMoreResponseData() []byte {
	if x, ok := m.GetFrame().(*ServerToClient_MoreResponseData); ok {
		return x.MoreResponseData
	}
	return nil
}

func (m *ServerToClient) GetCloseStream() *CloseStream {
	if x, ok := m.GetFrame().(*ServerToClient_CloseStream); ok {
		return x.CloseStream
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServerToClient) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServerToClient_OneofMarshaler, _ServerToClient_OneofUnmarshaler, _ServerToClient_OneofSizer, []interface{}{
		(*ServerToClient_ResponseHeaders)(nil),
		(*ServerToClient_ResponseMessage)(nil),
		(*ServerToClient_MoreResponseData)(nil),
		(*ServerToClient_CloseStream)(nil),
	}
}

func _ServerToClient_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServerToClient)
	// frame
	switch x := m.Frame.(type) {
	case *ServerToClient_ResponseHeaders:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResponseHeaders); err != nil {
			return err
		}
	case *ServerToClient_ResponseMessage:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResponseMessage); err != nil {
			return err
		}
	case *ServerToClient_MoreResponseData:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.MoreResponseData)
	case *ServerToClient_CloseStream:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloseStream); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServerToClient.Frame has unexpected type %T", x)
	}
	return nil
}

func _ServerToClient_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServerToClient)
	switch tag {
	case 2: // frame.response_headers
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Frame = &ServerToClient_ResponseHeaders{msg}
		return true, err
	case 3: // frame.response_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MessageData)
		err := b.DecodeMessage(msg)
		m.Frame = &ServerToClient_ResponseMessage{msg}
		return true, err
	case 4: // frame.more_response_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Frame = &ServerToClient_MoreResponseData{x}
		return true, err
	case 5: // frame.close_stream
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloseStream)
		err := b.DecodeMessage(msg)
		m.Frame = &ServerToClient_CloseStream{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServerToClient_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServerToClient)
	// frame
	switch x := m.Frame.(type) {
	case *ServerToClient_ResponseHeaders:
		s := proto.Size(x.ResponseHeaders)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerToClient_ResponseMessage:
		s := proto.Size(x.ResponseMessage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerToClient_MoreResponseData:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.MoreResponseData)))
		n += len(x.MoreResponseData)
	case *ServerToClient_CloseStream:
		s := proto.Size(x.CloseStream)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NewStream struct {
	MethodName           string    `protobuf:"bytes,1,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	RequestHeaders       *Metadata `protobuf:"bytes,2,opt,name=request_headers,json=requestHeaders,proto3" json:"request_headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NewStream) Reset()         { *m = NewStream{} }
func (m *NewStream) String() string { return proto.CompactTextString(m) }
func (*NewStream) ProtoMessage()    {}
func (*NewStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{2}
}
func (m *NewStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewStream.Unmarshal(m, b)
}
func (m *NewStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewStream.Marshal(b, m, deterministic)
}
func (dst *NewStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewStream.Merge(dst, src)
}
func (m *NewStream) XXX_Size() int {
	return xxx_messageInfo_NewStream.Size(m)
}
func (m *NewStream) XXX_DiscardUnknown() {
	xxx_messageInfo_NewStream.DiscardUnknown(m)
}

var xxx_messageInfo_NewStream proto.InternalMessageInfo

func (m *NewStream) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *NewStream) GetRequestHeaders() *Metadata {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

type MessageData struct {
	// The full size of the message.
	Size int32 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// The message data. This field should not be longer than 16kb (16,384
	// bytes). If the full size of the message is larger then it should be
	// split into multiple chunks. The chunking is done to allow multiple
	// access to the underlying gRPC stream by concurrent tunneled streams.
	// If very large messages were sent via a single chunk, it could cause
	// head-of-line blocking and starvation when multiple streams need to send
	// data on the one underlying gRPC stream.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageData) Reset()         { *m = MessageData{} }
func (m *MessageData) String() string { return proto.CompactTextString(m) }
func (*MessageData) ProtoMessage()    {}
func (*MessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{3}
}
func (m *MessageData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MessageData.Unmarshal(m, b)
}
func (m *MessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MessageData.Marshal(b, m, deterministic)
}
func (dst *MessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageData.Merge(dst, src)
}
func (m *MessageData) XXX_Size() int {
	return xxx_messageInfo_MessageData.Size(m)
}
func (m *MessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageData.DiscardUnknown(m)
}

var xxx_messageInfo_MessageData proto.InternalMessageInfo

func (m *MessageData) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *MessageData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CloseStream struct {
	ResponseTrailers     *Metadata      `protobuf:"bytes,1,opt,name=response_trailers,json=responseTrailers,proto3" json:"response_trailers,omitempty"`
	Status               *status.Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CloseStream) Reset()         { *m = CloseStream{} }
func (m *CloseStream) String() string { return proto.CompactTextString(m) }
func (*CloseStream) ProtoMessage()    {}
func (*CloseStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{4}
}
func (m *CloseStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloseStream.Unmarshal(m, b)
}
func (m *CloseStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloseStream.Marshal(b, m, deterministic)
}
func (dst *CloseStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseStream.Merge(dst, src)
}
func (m *CloseStream) XXX_Size() int {
	return xxx_messageInfo_CloseStream.Size(m)
}
func (m *CloseStream) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseStream.DiscardUnknown(m)
}

var xxx_messageInfo_CloseStream proto.InternalMessageInfo

func (m *CloseStream) GetResponseTrailers() *Metadata {
	if m != nil {
		return m.ResponseTrailers
	}
	return nil
}

func (m *CloseStream) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Metadata struct {
	Md                   map[string]*Metadata_Values `protobuf:"bytes,1,rep,name=md,proto3" json:"md,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{5}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (dst *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(dst, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetMd() map[string]*Metadata_Values {
	if m != nil {
		return m.Md
	}
	return nil
}

type Metadata_Values struct {
	Val                  []string `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata_Values) Reset()         { *m = Metadata_Values{} }
func (m *Metadata_Values) String() string { return proto.CompactTextString(m) }
func (*Metadata_Values) ProtoMessage()    {}
func (*Metadata_Values) Descriptor() ([]byte, []int) {
	return fileDescriptor_tunnel_3a42ada78c688164, []int{5, 0}
}
func (m *Metadata_Values) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata_Values.Unmarshal(m, b)
}
func (m *Metadata_Values) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata_Values.Marshal(b, m, deterministic)
}
func (dst *Metadata_Values) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata_Values.Merge(dst, src)
}
func (m *Metadata_Values) XXX_Size() int {
	return xxx_messageInfo_Metadata_Values.Size(m)
}
func (m *Metadata_Values) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata_Values.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata_Values proto.InternalMessageInfo

func (m *Metadata_Values) GetVal() []string {
	if m != nil {
		return m.Val
	}
	return nil
}

func init() {
	proto.RegisterType((*ClientToServer)(nil), "grpctunnel.ClientToServer")
	proto.RegisterType((*ServerToClient)(nil), "grpctunnel.ServerToClient")
	proto.RegisterType((*NewStream)(nil), "grpctunnel.NewStream")
	proto.RegisterType((*MessageData)(nil), "grpctunnel.MessageData")
	proto.RegisterType((*CloseStream)(nil), "grpctunnel.CloseStream")
	proto.RegisterType((*Metadata)(nil), "grpctunnel.Metadata")
	proto.RegisterMapType((map[string]*Metadata_Values)(nil), "grpctunnel.Metadata.MdEntry")
	proto.RegisterType((*Metadata_Values)(nil), "grpctunnel.Metadata.Values")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TunnelServiceClient is the client API for TunnelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TunnelServiceClient interface {
	// OpenTunnel creates a channel to the server which can be used to send
	// additional RPCs, all of which will be sent to the same server via a
	// single underlying gRPC stream. This can provide affinity for a "chatty"
	// sequence of calls, where the gRPC connection is load balanced (so there
	// may be multiple backend servers), but a particular "conversation" (which
	// may consist of numerous RPCs) needs to all go to a single server, for
	// consistency.
	OpenTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenTunnelClient, error)
	// OpenReverseTunnel creates a "reverse" channel, which allows the server to
	// act as a client and send RPCs to the client that creates the tunnel. It
	// is in most respects identical to OpenTunnel except that the roles are
	// reversed: the server initiates RPCs and sends requests and the client
	// replies to them and sends responses.
	OpenReverseTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenReverseTunnelClient, error)
}

type tunnelServiceClient struct {
	cc *grpc.ClientConn
}

func NewTunnelServiceClient(cc *grpc.ClientConn) TunnelServiceClient {
	return &tunnelServiceClient{cc}
}

func (c *tunnelServiceClient) OpenTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TunnelService_serviceDesc.Streams[0], "/grpctunnel.TunnelService/OpenTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &tunnelServiceOpenTunnelClient{stream}
	return x, nil
}

type TunnelService_OpenTunnelClient interface {
	Send(*ClientToServer) error
	Recv() (*ServerToClient, error)
	grpc.ClientStream
}

type tunnelServiceOpenTunnelClient struct {
	grpc.ClientStream
}

func (x *tunnelServiceOpenTunnelClient) Send(m *ClientToServer) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tunnelServiceOpenTunnelClient) Recv() (*ServerToClient, error) {
	m := new(ServerToClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tunnelServiceClient) OpenReverseTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenReverseTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TunnelService_serviceDesc.Streams[1], "/grpctunnel.TunnelService/OpenReverseTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &tunnelServiceOpenReverseTunnelClient{stream}
	return x, nil
}

type TunnelService_OpenReverseTunnelClient interface {
	Send(*ServerToClient) error
	Recv() (*ClientToServer, error)
	grpc.ClientStream
}

type tunnelServiceOpenReverseTunnelClient struct {
	grpc.ClientStream
}

func (x *tunnelServiceOpenReverseTunnelClient) Send(m *ServerToClient) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tunnelServiceOpenReverseTunnelClient) Recv() (*ClientToServer, error) {
	m := new(ClientToServer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TunnelServiceServer is the server API for TunnelService service.
type TunnelServiceServer interface {
	// OpenTunnel creates a channel to the server which can be used to send
	// additional RPCs, all of which will be sent to the same server via a
	// single underlying gRPC stream. This can provide affinity for a "chatty"
	// sequence of calls, where the gRPC connection is load balanced (so there
	// may be multiple backend servers), but a particular "conversation" (which
	// may consist of numerous RPCs) needs to all go to a single server, for
	// consistency.
	OpenTunnel(TunnelService_OpenTunnelServer) error
	// OpenReverseTunnel creates a "reverse" channel, which allows the server to
	// act as a client and send RPCs to the client that creates the tunnel. It
	// is in most respects identical to OpenTunnel except that the roles are
	// reversed: the server initiates RPCs and sends requests and the client
	// replies to them and sends responses.
	OpenReverseTunnel(TunnelService_OpenReverseTunnelServer) error
}

func RegisterTunnelServiceServer(s *grpc.Server, srv TunnelServiceServer) {
	s.RegisterService(&_TunnelService_serviceDesc, srv)
}

func _TunnelService_OpenTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TunnelServiceServer).OpenTunnel(&tunnelServiceOpenTunnelServer{stream})
}

type TunnelService_OpenTunnelServer interface {
	Send(*ServerToClient) error
	Recv() (*ClientToServer, error)
	grpc.ServerStream
}

type tunnelServiceOpenTunnelServer struct {
	grpc.ServerStream
}

func (x *tunnelServiceOpenTunnelServer) Send(m *ServerToClient) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tunnelServiceOpenTunnelServer) Recv() (*ClientToServer, error) {
	m := new(ClientToServer)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TunnelService_OpenReverseTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TunnelServiceServer).OpenReverseTunnel(&tunnelServiceOpenReverseTunnelServer{stream})
}

type TunnelService_OpenReverseTunnelServer interface {
	Send(*ClientToServer) error
	Recv() (*ServerToClient, error)
	grpc.ServerStream
}

type tunnelServiceOpenReverseTunnelServer struct {
	grpc.ServerStream
}

func (x *tunnelServiceOpenReverseTunnelServer) Send(m *ClientToServer) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tunnelServiceOpenReverseTunnelServer) Recv() (*ServerToClient, error) {
	m := new(ServerToClient)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _TunnelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpctunnel.TunnelService",
	HandlerType: (*TunnelServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenTunnel",
			Handler:       _TunnelService_OpenTunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OpenReverseTunnel",
			Handler:       _TunnelService_OpenReverseTunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/jhump/grpctunnel/tunnel.proto",
}

func init() {
	proto.RegisterFile("github.com/jhump/grpctunnel/tunnel.proto", fileDescriptor_tunnel_3a42ada78c688164)
}

var fileDescriptor_tunnel_3a42ada78c688164 = []byte{
	// 638 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcb, 0x4e, 0xdb, 0x4c,
	0x14, 0xc7, 0x71, 0x42, 0x02, 0x39, 0xe1, 0xe3, 0x32, 0xfa, 0x5a, 0x22, 0x53, 0xa9, 0x28, 0xab,
	0xa8, 0x42, 0x0e, 0xa5, 0xea, 0x45, 0x55, 0xbb, 0xe0, 0x26, 0xa5, 0x0b, 0x40, 0x1a, 0xa2, 0x6e,
	0xad, 0xc1, 0x3e, 0x24, 0x29, 0x1e, 0xdb, 0x9d, 0x19, 0x07, 0x51, 0xf5, 0x81, 0xaa, 0x4a, 0x7d,
	0x92, 0xbe, 0x54, 0x35, 0x17, 0x27, 0xb1, 0x8a, 0x28, 0x2b, 0x66, 0xce, 0xff, 0x7f, 0x2e, 0xfe,
	0x71, 0x26, 0xd0, 0x1b, 0x4d, 0xd4, 0xb8, 0xb8, 0x0a, 0xa2, 0x8c, 0xf7, 0xbf, 0x8c, 0x0b, 0x9e,
	0xf7, 0x47, 0x22, 0x8f, 0x54, 0x91, 0xa6, 0x98, 0xf4, 0xed, 0x9f, 0x20, 0x17, 0x99, 0xca, 0x08,
	0xcc, 0x05, 0x7f, 0x67, 0x94, 0x65, 0xa3, 0x04, 0xfb, 0x46, 0xb9, 0x2a, 0xae, 0xfb, 0xc8, 0x73,
	0x75, 0x67, 0x8d, 0xfe, 0xb6, 0x13, 0x45, 0x1e, 0xf5, 0xa5, 0x62, 0xaa, 0x90, 0x56, 0xe8, 0xfe,
	0xae, 0xc1, 0xfa, 0x71, 0x32, 0xc1, 0x54, 0x0d, 0xb3, 0x4b, 0x14, 0x53, 0x14, 0x64, 0x07, 0x5a,
	0x52, 0x09, 0x64, 0x3c, 0x9c, 0xc4, 0x1d, 0x6f, 0xd7, 0xeb, 0xd5, 0xe9, 0xaa, 0x0d, 0x7c, 0x8a,
	0xc9, 0x1b, 0x80, 0x14, 0x6f, 0x43, 0x7b, 0xef, 0xd4, 0x76, 0xbd, 0x5e, 0xfb, 0xe0, 0x49, 0x30,
	0x1f, 0x23, 0x38, 0xc7, 0xdb, 0x4b, 0x23, 0x0e, 0x96, 0x68, 0x2b, 0x2d, 0x2f, 0xe4, 0x08, 0x36,
	0x04, 0x7e, 0x2d, 0x50, 0xaa, 0x90, 0xa3, 0x94, 0x6c, 0x84, 0x9d, 0xba, 0x49, 0xde, 0x5e, 0x4c,
	0x3e, 0xb3, 0xd2, 0x09, 0x53, 0x6c, 0xb0, 0x44, 0xd7, 0x5d, 0x86, 0x8b, 0x92, 0x3d, 0xd8, 0xe2,
	0x99, 0xc0, 0xb0, 0x2c, 0x14, 0x33, 0xc5, 0x3a, 0xcb, 0xbb, 0x5e, 0x6f, 0x6d, 0xb0, 0x44, 0x37,
	0xb4, 0x44, 0xad, 0xa2, 0xf3, 0xc9, 0x5b, 0x80, 0x31, 0x4b, 0xae, 0xc3, 0x28, 0xc9, 0x24, 0x76,
	0x1a, 0xa6, 0xd9, 0xd3, 0xc0, 0x72, 0x08, 0x4a, 0x48, 0xc1, 0xa9, 0x86, 0xa4, 0x47, 0xd5, 0xde,
	0x63, 0x6d, 0x25, 0xfb, 0xd0, 0x8c, 0x58, 0x1a, 0x61, 0xd2, 0x69, 0xfe, 0x23, 0xc9, 0xf9, 0x8e,
	0x56, 0xa0, 0x71, 0x2d, 0x18, 0xc7, 0xee, 0xaf, 0x1a, 0xac, 0x5b, 0x8a, 0xc3, 0xcc, 0x52, 0x7d,
	0x98, 0xe6, 0x21, 0x6c, 0x0a, 0x94, 0x79, 0x96, 0x4a, 0x0c, 0xc7, 0xc8, 0x62, 0x14, 0xd2, 0x31,
	0xfd, 0xbf, 0x8a, 0x45, 0xb1, 0xd8, 0x32, 0xd9, 0x28, 0xfd, 0x03, 0x6b, 0x27, 0x27, 0x0b, 0x25,
	0x1e, 0x4d, 0x76, 0x56, 0xa5, 0x44, 0x1b, 0x00, 0x71, 0x68, 0x5d, 0xa9, 0x0a, 0xdb, 0x4d, 0xcb,
	0xd6, 0x4a, 0x06, 0xee, 0x07, 0x58, 0x33, 0x5c, 0xcb, 0x45, 0x68, 0xfc, 0xdd, 0xd1, 0xc0, 0x9c,
	0xad, 0x42, 0x3b, 0x9a, 0x5f, 0xe7, 0xbc, 0x6e, 0xa0, 0x35, 0xdb, 0x17, 0xf2, 0x1c, 0xda, 0x1c,
	0xd5, 0x38, 0x8b, 0xc3, 0x94, 0x71, 0x34, 0xac, 0x5a, 0x14, 0x6c, 0xe8, 0x9c, 0x71, 0x24, 0x1f,
	0xe7, 0x3b, 0xf4, 0x08, 0x58, 0xb3, 0xf5, 0x71, 0xa4, 0xba, 0xaf, 0xa1, 0xbd, 0x40, 0x81, 0x10,
	0x58, 0x96, 0x93, 0x6f, 0xb6, 0x4f, 0x83, 0x9a, 0xb3, 0x8e, 0x99, 0x0f, 0xd7, 0x65, 0xd7, 0xa8,
	0x39, 0x77, 0xbf, 0x43, 0x7b, 0xe1, 0x53, 0xc8, 0x21, 0x6c, 0xcd, 0x20, 0x29, 0xc1, 0x26, 0x89,
	0x1e, 0xc3, 0x7b, 0x60, 0x8c, 0xd9, 0xbf, 0x67, 0xe8, 0xdc, 0xe4, 0x05, 0x34, 0xed, 0x1b, 0x74,
	0xe3, 0x93, 0x72, 0xc1, 0x44, 0x1e, 0x05, 0x97, 0x46, 0xa1, 0xce, 0xd1, 0xfd, 0xe1, 0xc1, 0x6a,
	0x59, 0x8a, 0xec, 0x41, 0x8d, 0xeb, 0x25, 0xaa, 0xf7, 0xda, 0x07, 0xcf, 0xee, 0x6b, 0x16, 0x9c,
	0xc5, 0xa7, 0xa9, 0x12, 0x77, 0xb4, 0xc6, 0x63, 0xdf, 0x87, 0xe6, 0x67, 0x96, 0x14, 0x28, 0xc9,
	0x26, 0xd4, 0xa7, 0x2c, 0x31, 0x89, 0x2d, 0xaa, 0x8f, 0x3e, 0x85, 0x15, 0x67, 0xd5, 0xe2, 0x0d,
	0xde, 0x39, 0xdc, 0xfa, 0x48, 0x5e, 0x42, 0x63, 0xaa, 0x13, 0xdd, 0x78, 0x3b, 0xf7, 0x76, 0xb2,
	0xa5, 0xa9, 0x75, 0xbe, 0xaf, 0xbd, 0xf3, 0x0e, 0x7e, 0x7a, 0xf0, 0xdf, 0xd0, 0xb8, 0xf4, 0x13,
	0x98, 0x44, 0x48, 0x06, 0x00, 0x17, 0x39, 0xa6, 0x36, 0x48, 0xfc, 0xea, 0x76, 0x2c, 0xfe, 0xe6,
	0xf8, 0x15, 0xad, 0xfa, 0x82, 0x7a, 0xde, 0xbe, 0x47, 0x2e, 0x60, 0x4b, 0x57, 0xa2, 0x38, 0x45,
	0x21, 0xf1, 0xbe, 0x82, 0xd5, 0x24, 0xff, 0x81, 0x66, 0xba, 0xe0, 0x55, 0xd3, 0x3c, 0xe6, 0x57,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xe7, 0xc0, 0xe6, 0x6c, 0x05, 0x00, 0x00,
}
